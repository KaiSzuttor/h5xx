* implement class h5xx::dataset, in analogy to h5xx::attribute

  As a difference, multiple writes to different hyperslabs of the same dataset
  can occur (incremental write). Hence, creation and writing have to be
  separate functions. 

  Suggestion: creation occurs in the constructor (or in a free function?),
  writing is separate free function and will eventually support
  hyperslab addressing for incremental and parallel I/O.

  Example:

    // create dataset via constructor
    h5xx::dataset dataset(group, name, datatype, dataspace, policies); // variant of the constructor

    // alternative: pass data variable to derive datatype and dataspace,
    // template specialisation is simpler if it is a free function
    template <typename T>
    h5xx::dataset create_dataset(group, name, data);

    // write to dataset (free function)
    template <typename T>
    h5xx::write<T>(h5xx::dataset const& dataset, T const& data, hyperslab_index);

    // read from dataset,
    // passing data as argument gives automatically access to the type T
    template <typename T>
    h5xx::read<T>(h5xx::dataset const& dataset, T& data, hyperslab_index);

* implement creation properties for h5xx::dataset constructors
    - missing filters: H5Pset_scaleoffset, H5Pset_nbit
    - fill_value (wraps H5Pset_fill_value and perhaps H5Pset_fill_time)
    - track_times (wraps H5Pset_obj_track_times) - "on" by default?
    - low urgency: alloc_time (wraps H5Pset_alloc_time)

    - example:

    auto storage_policy = policy::storage::chunked(boost::array const& shape).add(policy::filter::deflate(6));
    h5xx::dataset ds(..., storage_policy, fill_value(5)); // create dataset via constructor
    write(ds, data);

* implement hyperslab (policy?) for reading/writing h5xx::dataset, can we
  introduce a slicing notation as in Python?

    - a class h5xx::hyperslab to specify start, count, stride, block,
        the class could be passed to read/write directly for simple selections
        (without the need to manage dataspace in the application code)

    - add method to dataspace:
        select(hyperslab const&, dataspace::mode m)
      where mode is dataspace::{set,and,or,xor,...} (see h5xx::file for a similar 'mode' variable)

* implement class h5xx::datatype, we have already h5xx::ctype<T>
  (removing any explicit calls to H5T*, look at output of `grep -R H5T h5xx/`)

    - ctype should become part of datatype (as needed)

* make support of Boost C++ types optional to relax build requirements

    - in C++98 we can't avoid TR1 things such as enable_if, array, etc.
    - the "complex" types are found only in certain headers, which may be included or not

